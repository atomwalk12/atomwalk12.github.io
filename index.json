[{"content":"Main Workflow Figure ?? represents an illustration of the development process, organised around a two-stage workflow for training a reasoning language model.\nFigure\u0026nbsp;1: The development process includes five main phases: (1) SFT Dataset Generation (M.1-M.3), (2) SFT Training (M.4), (3) RLVR Data Curation (M.5), (4) RLVR Training (M.6), and (5) Deployment (M.7-M.9). M.1 Initial Raw Data Collection: Creating template schemes for various problem types (e.g. Matrix Multiplication, Linear Equations, etc.). Defines hyperparameters to ensure varying difficulty levels concerning the format and output constraints. M.2 Synthetic Data Generation: Generating raw problems via synthetic data generation. M.3 Data Distillation: Preparing the dataset for the Supervised Fine-Tuning (SFT) stage. S.1 Chain-of-Thought (CoT) Generation: Generating step-by-step reasoning traces for collected questions using a powerful \u0026ldquo;teacher\u0026rdquo; model (i.e. DeepSeek-R1). S.2 Verification: Validating the correctness of answers and CoTs through methods like Math Verify or LLM judges. S.3 Difficulty-Based Filtering: Selecting problems based on their difficulty level. Samples with moderate pass rates are retained, while those that are too easy or too hard are filtered out. Filtering may also involve learning impact measurement or off-the-shelf LLM judges. S.4 Rigorous Data Cleaning: Performing deduplication (via embedding similarity or n-gram), rejection sampling, and decontamination to ensure high-quality and unbiased data. M.4 Supervised Fine-tuning (SFT) Training: To enable the base model to imitate high-quality reasoning traces from stronger models. This phase serves as a baseline for stable training. The entire reasoning dataset is used. M.5 Reinforcement Learning from Verifiable Rewards (RLVR) Data Curation: This is a distinct and critical phase that involves preparing high-quality, verifiable datasets specifically for RL training. This includes: Construction of Verified Questions and Answers:: Gathering datasets for RL, often focused on math problems that can be objectively verified via automated tools. Difficulty-Based Filtering: RL datasets are often designed to include samples where models are likely to make mistakes (i.e., moderate pass rates), as samples that are too easy or too hard offer limited learning opportunities and are often filtered out. This differs from SFT\u0026rsquo;s general emphasis on difficulty and diversity to ensure data richness. Detailed Pre-processing (Verification, Filtering, Cleaning): Rigorous steps similar to SFT data preparation, but tailored for RL (e.g., filtering for samples with moderate pass rates, removing unverifiable formats, and ensuring decontamination). M.6 Reinforcement Learning from Verifiable Rewards (RLVR) Training: The core RL phase that further enhances reasoning capabilities. This process includes: V.1 RL Algorithm Implementation: Utilizing and adapting algorithms such as PPO, GRPO, or their variants. V.2 Reward System Design: Defining rule-based reward functions (e.g., accuracy, format, length) that guide the model\u0026rsquo;s learning process. V.3 Sampling Strategies and Curriculum Learning: Employing techniques like dynamic sampling, epoch-level history resampling, or progressively increasing context/response length to optimize training efficiency and stability. V.4 Reasoning Model: As a result of the actor-critic optimisations, a reasoning model is obtained. M.7 Model Evaluation: Attentive assessment of the Reasoning Language Model\u0026rsquo;s (RLM) performance on relevant benchmarks (e.g., AIME, MATH500). M.8 Further Refinement: The model can be quantized to facilitate easier adoption. M.9 Deployment and Release: Making the trained reasoning language model and dataset available on HuggingFace. Experimental setting This library utilises Qwen3-1.7B as the base model. However, other models that have been considered include: Qwen3-4B, Qwen3-0.6B, phi4-4B-instruct, gemma-3-1B and gemma-3-4B.\nPost-training Training methods. This library opts to analyse the model\u0026rsquo;s emergent reasoning abilities in two ways. One method involves Reinforcement Learning with Verifiable Rewards (RLVR), while the other is centred around a distillation process involving existing strong reasoning models. Figure ?? provides an illustration of the two processes. Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) suggests that training small models only using distillation yields better results than using RLVR, however in this library both methods are explored.\nFigure\u0026nbsp;2: Overview of the experimental setting in Qwen3: (1) RLVR for large models (\u0026gt;32B parameters), (2) Distillation for small models (\u0026lt;14B parameters). Our library demonstrates both approaches on a common base model: Qwen3-1.7B. (Image Source: Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) Experiment 1: RLVR Reinforcement Learning with Verifiable Rewards (RLVR) is a strategy for training LLMs where the reward signal is directly derived from the correctness of the model\u0026rsquo;s final answer on verifiable tasks. The technique was extensively used and pioneered by DeepSeek with their DeepSeek-R1-Zero paper (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ). Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) subsequently refines the process to include 3 key phases: cold-start SFT, RLVR and tool use.\nStep 1: Cold-Start SFT. SFT generally teaches the model to follow a desired prompt format, effectively facilitating convergence in the subsequent stages. This is necessary as pre-trained models are generally trained for text-completion, making their adherence to question-answering prompts difficult.\nQwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) utilises a challenging reasoning dataset exclusively for this phase, while Qwen2.5 (Qwen\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Qwen\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen2.5 Technical Report. https://doi.org/10.48550/arXiv.2412.15115 ) opts for a combination of both reasoning and non-reasoning traces of varying difficulty.\nStep 2: RLVR Training. The second phase (RLVR) is a critical post-training stage, designed to improve a model\u0026rsquo;s reasoning abilities. This ensures that through a step-by-step thinking process the solutions become verifiable.\nStep 3: Tool Use. Lastly, we anticipate a last phase designed to teach the model to use tools. This is a generalisation of the RLVR training process, where the model is trained to use tools to solve problems.\nExperiment 2: Distillation Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) suggests that the small models ($\\leq$ 14B parameters) perform better when trained using distillation instead of the full-fledged RLVR training. This distillation process is composed of two phases, namely off-policy and on-policy distillation.\nThis section introduces the key concepts around the knowledge-distillation process, first proposed by (Hinton\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2015 Hinton\u0026#32; Geoffrey,\u0026#32;et al. \u0026#32; (2015). \u0026#32;Distilling the Knowledge in a Neural Network. https://doi.org/10.48550/arXiv.1503.02531 ). Also, an analysis of the theory involved is available in this post.\nOff-policy Distillation. Aims to to use the outputs of a teacher (i.e. Qwen3-32B) model to demonstrate basic reasoning skills to a smaller model (i.e. Qwen3-1.7B-Base). This phase is less memory intensive than the on-policy phase as the responses of the teacher can be generated in advance. The smaller model is fine-tuned on the teacher\u0026rsquo;s responses, which lays as a solid foundation for the on-policy phase.\nOn-policy Distillation. During this phase, both the student and the teacher generate their own responses to queries sampled from the reasoning dataset. The student model is then fine-tuned by aligning its logits with those of the teacher model by minimising KL-divergence. This allows the student to expand its exploration space and enhance its reasoning abilities, while requiring a substantially lesser amount of GPU hours (1/10th) compared to utilising solely RLVR.\nImplementation Surveys. There exist various surveys on the topic of knowledge distillation (Xu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2024 Xu\u0026#32; Xiaohan,\u0026#32;et al. \u0026#32; (2024). \u0026#32;A Survey on Knowledge Distillation of Large Language Models. https://doi.org/10.48550/arXiv.2402.13116 ;\u0026#32;Gou\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2021 Gou\u0026#32; Jianping,\u0026#32;et al. \u0026#32; (2021). \u0026#32;Knowledge Distillation: A Survey. International Journal of Computer Vision,\u0026#32;129(6).\u0026#32;1789â€“1819. https://doi.org/10.1007/s11263-021-01453-z ), with various studies effectively demonstrating correct implementations of the distillation process. Below are compiled insights on the distillation process.\nTraining Heuristics. FastFormers (Kim\u0026#32;\u0026amp;\u0026#32;Awadalla,\u0026#32;2020 Kim\u0026#32; Young Jin\u0026#32;\u0026amp;\u0026#32;Awadalla\u0026#32; Hany Hassan. \u0026#32; (2020). \u0026#32;FastFormers: Highly Efficient Transformer Models for Natural Language Understanding. https://doi.org/10.48550/arXiv.2010.13382 ) provides great insights into the mechanics of the distillation process, namely what works and what doesn\u0026rsquo;t.\nNOTE: The FastFormers paper suggests differentiating between task-agnostic and task-specific fine-tuning. The later involves fine-tuning the teacher on the dataset prior to initiating the distillation process, which may lead to better accuracy. See Figure 1 of the paper.\nMoreover, it suggests that the distillation process is only effective as long as the tokenizers of each model produce the same output given similar inputs. The study postulates that different tokenizer embedding spaces result in different output embedding spaces, and this leads to knowledge transfer being not as effective. So, a similar check is necessary:\nfrom transformers import AutoTokenizer # Initialise tokenizers teacher = AutoTokenizer.from_pretrained(TEACHER_ID) student = AutoTokenizer.from_pretrained(STUDENT_ID) # Input sample = \u0026#34;Some sample text.\u0026#34; # Assert results assert teacher(sample) == student(sample), \u0026#34;Teacher/Student tokenizer mismatch\u0026#34; Dataset generation Dataset generation: The generation of the dataset is composed of a two-phase filtering process:\nQuery (Complexity) Filtering: the purpose is to ensure that only complex problems are included in the dataset. A powerful model (i.e. Qwen2.5-72B-Instruct) tries to solve the problem without chain-of-thought reasoning. If the answer is correct, the problem is considered simple and is discarded. Otherwise, if the attempt fails, the problem is included in the dataset.\nResponse Filtering: This process includes a verification step, where we ensure that only correct answers are included in the final long-CoT dataset. Because of this, answers that are incorrect or contain substantial repetition are discarded.\n","permalink":"https://atomwalk12.github.io/posts/lingalgzero/linalgzero/","summary":"A toolkit for generating a linear algebra dataset and training models for linear algebra reasoning.","title":"LinAlgZero: A linear algebra dataset for reasoning"},{"content":"The following notes are borrowed from (Zhang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Zhang\u0026#32; Chong,\u0026#32;et al. \u0026#32; (2025). \u0026#32;100 Days After DeepSeek-R1: A Survey on Replication Studies and More Directions for Reasoning Language Models. https://doi.org/10.48550/arXiv.2505.00551 ). I will revise them as my understanding improves.\nSupervised Fine-tuning Definition\u0026nbsp;1\u0026nbsp;(SFT Loss).\u0026nbsp; Given a dataset $\\mathcal{D}_{\\text{SFT}} \\triangleq \\left\\{ (q_i, c_i) \\right\\}_{i=1}^{|\\mathcal{D}|}$, where each sample $(q_i, c_i)$ consists of a question $q_i$ and a long CoT $c_i$. The long CoT can be further decomposed into a complex intermediate rationale followed by a final answer. SFT updates the parameters of the policy model $\\pi_{\\theta}$ by minimizing the negative log-likelihood loss: $$ \\begin{aligned} \\mathcal{L}_{\\text{SFT}}(\\theta) \\triangleq - \\mathbb{E}_{(q, c) \\sim \\mathcal{D}_{\\text{SFT}}} \\left[ \\log \\pi_{\\theta}(c \\mid q) \\right], \\end{aligned} $$ where $\\pi_{\\theta}(c \\mid q)$ denotes the probability assigned by the policy to the CoT response $c$ conditioned on the question $q$. This objective encourages the model to imitate the supervised demonstrations by maximizing the likelihood of the reference completions. In the following example, if each sample is equally likely to be selected, then the expectation operator is averaging the negative log-likelihood loss across all training examples in the dataset: $$ \\mathbb{E}_{(q,c) \\sim \\mathcal{D}_{\\text{SFT}}}[\\log \\pi_\\theta(c | q)] = \\frac{1}{|\\mathcal{D}_{\\text{SFT}}|} \\sum_{i=1}^{|\\mathcal{D}_{\\text{SFT}}|} \\log \\pi_\\theta(c_i | q_i) $$ LLM Policy Optimization Recent studies have introduced a groundbreaking post-training paradigm that enhances LLMs' reasoning capabilities through RL-based training. In this framework, the LLM's answer generation process for each query is formulated as an answer sampling policy, and our objective is to optimize this LLM policy to maximize the expected reward of the generated responses. According to (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ;\u0026#32;Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ;\u0026#32;Team\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Team\u0026#32; Kimi,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Kimi k1.5: Scaling Reinforcement Learning with LLMs. https://doi.org/10.48550/arXiv.2501.12599 ), large-scale RL-based LLM policy optimization enables the base LLM to achieve a steady improvement in reasoning accuracy while also exhibiting the emergence of long-chain reasoning in its chain-of-thought. Definition\u0026nbsp;2\u0026nbsp;(LLM Policy Optimization).\u0026nbsp; Suppose each reasoning data pair $(q,a)$ is i.i.d sampled from an underlying distribution $\\mathcal{D}$, where each $q$ is a query and $a$ is the corresponding ground-truth answer. Let $\\pi_{\\theta}(\\cdot | \\cdot)$ be the target LLM policy parameterized by $\\theta$. The expected reward of the LLM on a sample $(q,a)$ is $\\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot | q)} [r(o, a)]$, where $o$ is an LLM-generated response to $q$, and $r(\\cdot,\\cdot)$ is a predefined reward function that quantifies whether the response $o$ yields $a$. The objective of RL-based fine-tuning is to maximize the expected reward over the data distribution, i.e., $$ \\begin{align*} \\max_{\\theta} J(\\pi_{\\theta}) \\triangleq \\mathbb{E}_{(q,a)\\sim \\mathcal{D}} \\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot|q)} [r(o, a)]. \\end{align*} $$ A straightforward approach to maximize $J(\\pi_{\\theta})$ is to gradually improve the LLM's parameter $\\theta$ towards the policy gradient direction $\\nabla_{\\theta} J(\\pi_{\\theta})$. However, since $ \\nabla_{\\theta} \\mathbb{E}_{o \\sim \\pi_{\\theta}(\\cdot | q)} r(o, a) $ is the gradient of an integral dependent on $ \\pi_\\theta $, $ \\nabla_{\\theta} J(\\pi_{\\theta}) $ is intractable to compute via standard Monte Carlo sampling. Fortunately, the RL community has developed two powerful policy gradient estimators: REINFORCE (Williams,\u0026#32;1992 Williams\u0026#32; Ronald J.. \u0026#32; (1992). \u0026#32;Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning,\u0026#32;8(3).\u0026#32;229â€“256. https://doi.org/10.1007/BF00992696 ) and Importance Sampling (Sutton\u0026#32;\u0026amp;\u0026#32;Barto,\u0026#32;2025 Sutton\u0026#32; Richard\u0026#32;\u0026amp;\u0026#32;Barto\u0026#32; Andrew.(2025,\u0026#32;6/27).\u0026#32;Retrieved from\u0026#32; http://incompleteideas.net/book/the-book-2nd.html ): $$\\small \\begin{align*} \\nabla_{\\theta} \\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot|q)} r(o, a) = \\begin{cases} \\mathbb{E}_{o \\sim \\pi_{\\theta}(\\cdot|q)} \\left[ \\nabla_{\\theta} \\log \\pi_{\\theta}(o|q) \\cdot r(o, a) \\right]\\ \u0026\\text{(REINFORCE)}, \\\\ \\mathbb{E}_{o \\sim \\pi_{\\theta'}(\\cdot|q)} \\left[ \\nabla_{\\theta} \\left( \\frac{\\pi_{\\theta}(o|q)}{\\pi_{\\theta'}(o|q)} \\right) \\cdot r(o, a) \\right]\\ \u0026\\text{(Importance Sampling)}, \\end{cases} \\end{align*} $$ where $\\pi_{\\theta'}$ is any parameter-frozen LLM policy. Hence, the policy gradient $\\nabla_{\\theta} J(\\pi_\\theta)$ can be effectively approximated using standard Monte Carlo sampling: for each data pair $(q,a)$, we independently generate $G$ responses to $q$, denoted by $\\{o_i\\}_{i=1}^G$, using the current LLM $\\pi_\\theta$ or the frozen LLM $\\pi_{\\theta'}$, and then approximate the policy gradient estimators by $$\\footnotesize \\begin{align*} \\nabla_{\\theta} J(\\pi_\\theta) = \\begin{cases} \\mathbb{E}_{(q,a)\\sim \\mathcal{D},\\{o_i\\}_{i=1}^G\\sim \\pi_{\\theta}(\\cdot|q)} \\left[ \\frac{1}{G} \\sum_{i=1}^G \\nabla_{\\theta} \\log \\pi_{\\theta}(o_i|q) \\cdot r(o_i, a) \\right] \u0026\\text{(REINFORCE)}, \\\\ \\mathbb{E}_{(q,a)\\sim \\mathcal{D},\\{o_i\\}_{i=1}^G\\sim \\pi_{\\theta'}(\\cdot|q)} \\left[ \\frac{1}{G} \\sum_{i=1}^G \\nabla_{\\theta} \\left( \\frac{\\pi_{\\theta}(o_i|q)}{\\pi_{\\theta'}(o_i|q)} \\right) \\cdot r(o_i, a) \\right] \u0026 \\text{(Importance Sampling)}, \\end{cases} \\end{align*} $$ For each query $q$, the procedure of generating $G$ independent responses $\\{o_{i}\\}_{j=1}^G$ from $\\pi_{\\theta}(\\cdot|q)$ is called the `rollout phase'. During this phase, the LLM policy explores enormous response samples of varying quality. Then $\\theta$ is updated to increase the likelihood $ \\pi_{\\theta}(o_i|q) $ where $ r(o_i, a)$ is large, thereby improving the likelihood of generating responses with high rewards. Specifically, REINFORCE is an on-policy method that requires generating new rollouts using the latest LLM policy $ \\pi_{\\theta} $. In contrast, the importance sampling estimator can be implemented in an off-policy manner with improved sampling efficiency, as it can reuse past rollouts generated from $\\pi_{\\theta'}$ by storing the corresponding probability terms $ \\pi_{\\theta'}(o_i | q)$. A common choice is to implement $\\pi_{\\theta'}$ as $\\pi_{\\theta_{\\mathrm{old}}}$, a past snapshot of the target LLM $\\pi_\\theta$, which is updated periodically. In practice, the reward signals $\\{r(o_i, a)\\}_{i=1}^G$ are highly sparse, leading to high variance in rollout phases and policy gradient estimation. To mitigate these issues, various techniques have been developed to stabilize LLM policy gradient estimation in (\\ref{eq:rl_policy_grad_estimator}). These techniques generally fall into three categories: 1) reducing sampling variance by reward normalization or using actor-critic advantage estimation, 2) stabilizing parameter updates by clipping the importance sampling weight $ \\pi_\\theta(o_i|q) / \\pi_{\\theta_{\\mathrm{old}}}(o_i|q)$, and 3) constraining policy shifts by penalizing the KL-divergence $\\mathrm{KL}(\\pi_{\\theta} | \\pi_{\\mathrm{ref}})$ between the current LLM policy $\\pi_{\\theta}$ and a fixed reference LLM policy $\\pi_{\\mathrm{ref}}$. RLVR PPO Since its introduction in (Schulman\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2017 Schulman\u0026#32; John,\u0026#32;et al. \u0026#32; (2017). \u0026#32;Proximal Policy Optimization Algorithms. https://doi.org/10.48550/arXiv.1707.06347 ), Proximal Policy Optimization (PPO) has become one of the most popular actor-critic RL algorithms for LLM policy optimization (Ouyang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2022 Ouyang\u0026#32; Long,\u0026#32;et al. \u0026#32; (2022). \u0026#32;Training language models to follow instructions with human feedback. ArXiv.\u0026#32;Retrieved from\u0026#32; https://www.semanticscholar.org/paper/Training-language-models-to-follow-instructions-Ouyang-Wu/d766bffc357127e0dc86dd69561d5aeb520d6f4c ;\u0026#32;Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ). In addition to the target LLM policy $\\pi_\\theta$, which serves as the actor model, PPO introduces a critic model $V_{\\phi} $â€”another LLM designed to learn the value for the responses generated by the actor LLM $\\pi_\\theta$. Specifically, the PPO objective is $$\\small \\begin{equation*} \\begin{aligned} J_{\\mathrm{PPO}}(\\pi_\\theta) \\triangleq \u0026\\ \\mathbb{E}_{(q, a) \\sim \\mathcal{D},\\left\\{o_i\\right\\}_{i=1}^G \\sim \\pi_{\\theta_{\\text{old}}}(\\cdot \\mid q)} \\\\ \\Bigg[ \u0026 \\frac{1}{G} \\sum_{i=1}^G \\frac{1}{\\left| o_i \\right|} \\sum_{t=1}^{\\left|o_i\\right|} \\left( \\min \\Big( r_{i, t}(\\theta) \\textcolor{red}{\\hat{A}_{i, t}(\\phi)}, \\textcolor{red}{\\operatorname{clip}}\\left(r_{i, t}(\\theta), 1 - \\varepsilon, 1 + \\varepsilon\\right) \\textcolor{red}{\\hat{A}_{i, t}(\\phi)} \\Big) \\right) \\Bigg], \\end{aligned} \\end{equation*} $$ where $r_{i,t}(\\theta)\\triangleq \\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})/ \\pi_{\\theta_{\\mathrm{old}}}(o_{i,t}|q,o_{i, \u003c t})$ denotes the likelihood ratio between the current LLM policy $\\pi_\\theta$ and the past LLM policy $\\pi_{\\theta'}$ calculated on the $t$-th token prediction step; $\\hat{A}_{i, t}(\\phi)$ denotes the Generalized Advantage Estimator (GAE) (Schulman\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2018 Schulman\u0026#32; John,\u0026#32;et al. \u0026#32; (2018). \u0026#32;High-Dimensional Continuous Control Using Generalized Advantage Estimation. https://doi.org/10.48550/arXiv.1506.02438 ) computed using the estimated value $V_{\\phi}(o_{i,t}|q,o_{i, \u003c t})$, which estimates the quality of each response generation state. $ V_{\\phi} $ is trained along with $\\pi_{\\theta}$ to predict the value of the response generated by $\\pi_{\\theta}$. In practice (Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ), GAE is observed to be a more robust response quality estimator than the raw reward $r(q_i,a^*_i)$, leading to more stable LLM policy optimization. GRPO Group Relative Policy Optimization (GRPO) is first proposed (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ) as an effective and efficient variant of PPO. Specifically, GRPO discards the critic model and GAE calculation in PPO to improve efficiency and memory consumption. To reduce the reward sampling variance, GRPO normalizes the rewards within a group of $G$ rollout outs. In addition to clipping the likelihood ratio terms, GRPO further introduces KL-divergence penalty to ensure that $\\pi_\\theta$ would not be driven far away from the initial SFT LLM. Specifically, the GRPO objective is\n$$\\footnotesize \\begin{equation*} \\begin{align*} J_{\\mathrm{GRPO}}(\\pi_\\theta) \\triangleq \u0026\\ \\mathbb{E}_{(q, a) \\sim \\mathcal{D},\\left\\{o_i\\right\\}_{i=1}^G \\sim \\pi_{\\theta_{\\text{old}}}(\\cdot \\mid q)} \\\\ \\Bigg[ \u0026 \\frac{1}{G} \\sum_{i=1}^G \\frac{1}{\\left| o_i \\right|} \\sum_{t=1}^{\\left|o_i\\right|} \\left( \\min \\Big( r_{i, t}(\\theta) \\textcolor{red}{\\hat{A}_{i, t}}, \\operatorname{clip}\\left(r_{i, t}(\\theta), 1 - \\varepsilon, 1 + \\varepsilon\\right) \\textcolor{red}{\\hat{A}_{i, t}} \\Big) - \\textcolor{red}{\\beta \\mathrm{KL}(\\pi_{\\theta}|\\pi_{\\mathrm{ref}})}_{i,t} \\right) \\Bigg], \\end{align*} \\end{equation*} $$ where $\\hat{A}_{i,t} \\triangleq (r(o_i,a) - \\mathrm{mean}(\\{r(o_i,a)\\}_{i=1}^G))/\\mathrm{std}(\\{r(o_i,a)\\}_{i=1}^G)$ denotes the group relative reward, and $\\mathbf{r} \\triangleq \\{r(o_i,a)\\}_{i=1}^G$ denotes the rewards of the response group corresponding to each sample $(q,a)$. GRPO also incorporates the K3 KL-divergence estimator (Schulman,\u0026#32;2020 Schulman\u0026#32; John.(2020,\u0026#32;3/7).\u0026#32;Retrieved from\u0026#32; http://joschu.net/blog/kl-approx.html ): $$ \\begin{align*} \\mathrm{KL}(\\pi_{\\theta}|\\pi_{\\mathrm{ref}})_{i,t} \\triangleq \\frac{\\pi_{\\mathrm{ref}}(o_{i,t}|q,o_{i, \u003c t})}{\\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})} - \\log \\frac{\\pi_{\\mathrm{ref}}(o_{i,t}|q,o_{i, \u003c t})}{\\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})} - 1. \\end{align*} $$ DeepSeek-R1 (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ) shows that GRPO achieves stable large-scale LLM policy optimization that incentivises the long CoT pattern in large-scale LLMs.\nDistillation The following concepts are based on (Hinton\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2015 Hinton\u0026#32; Geoffrey,\u0026#32;et al. \u0026#32; (2015). \u0026#32;Distilling the Knowledge in a Neural Network. https://doi.org/10.48550/arXiv.1503.02531 ). They are currently being written.\nGradient Accumulation Definition\u0026nbsp;3\u0026nbsp;(Gradient Accumulation).\u0026nbsp; Below is an explanation on how to adjust the gradient accumulation steps when changing the number of GPUs. The goal is to keep the Global Batch Size constant. The formula for it is: $$\\footnotesize \\text{Global Batch Size} = (\\text{Number of GPUs}) \\times (\\text{Per-Device Batch Size}) \\times (\\text{Gradient Accumulation Steps}) $$ Derivation: The goal is to show how to adjust the parameters to keep the Global Batch Size constant when the number of GPUs changes. Suppose we use the subscript _old for the original values and _new for the new values. The principle is:\n$$ \\text{Global Batch Size}_{old} = \\text{Global Batch Size}_{new} $$ Therefore: $$\\footnotesize (\\text{GPUs}_{old} \\times \\text{Batch Size}_{old} \\times \\text{Accumulation}_{old}) = (\\text{GPUs}_{new} \\times \\text{Batch Size}_{new} \\times \\text{Accumulation}_{new}) $$ To find the new required number of gradient accumulation steps, the formula is rearranged as follows: $$ \\text{Accumulation}_{new} = \\frac{(\\text{GPUs}_{old} \\times \\text{Batch Size}_{old} \\times \\text{Accumulation}_{old})}{(\\text{GPUs}_{new} \\times \\text{Batch Size}_{new})} $$ This shows how the gradient accumulation steps are affected by the number of GPUs. \u0026#9724; Example\u0026nbsp;1\u0026nbsp;(Gradient Accumulation).\u0026nbsp;Suppose the following values are given:\nGPUs_old: 8 Batch Size_old: 16 Accumulation_old: 4 GPUs_new: 1 Batch Size_new: 16 (this is limited by the GPU\u0026rsquo;s memory) Plugging these into the formula to find the new gradient accumulation steps: $$ \\text{Accumulation}_{new} = \\frac{(8 \\times 16 \\times 4)}{(1 \\times 16)} = \\frac{512}{16} = 32 $$ This is why the gradient_accumulation_steps should be updated to 32 in the configuration file.\n","permalink":"https://atomwalk12.github.io/posts/lingalgzero/theory/","summary":"A toolkit for generating a linear algebra dataset and training models for linear algebra reasoning.","title":"LinAlgZero: Theory"},{"content":" Q:\u0026nbsp;How can I get an update when a new post comes out?\nIt is possible to subscribe to the RSS feed to be notified via email. Q:\u0026nbsp;How to find interesting Wikipedia articles?\nPetScan is a useful tool to filter and analyse Wikipedia articles based on categories and other criteria. I find it useful for finding new topics to read about. Q:\u0026nbsp;How do you organize your code snippets?\nI use Github Gists to store code that is useful to reuse across projects. Q:\u0026nbsp;Blogs that are particularly interesting?\nHuggingface Blog Deeplearning.ai ","permalink":"https://atomwalk12.github.io/resources/","summary":"A list of resources I find useful.","title":"FAQ"}]