[{"content":"DeepSeek-R1 Training Phases DeepSeek-R1 (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ) goes through a 4 stage training pipeline, as shown in Figure ?? .\nFigure\u0026nbsp;1: The four stages of DeepSeek-R1 training pipeline. CS SFT + RORL stand for Cold-Start SFT + Reasoning-Oriented Reinforcement Learning respectively. (Image Source: Harris Chan)\n1. Cold-Start. This involves constructing and collecting a small amount of long Chain-of-Thought (CoT) data to fine-tune the DeepSeek-V3-Base model. The purpose of this initial Supervised Fine-Tuning (SFT) is to prevent an unstable early cold start phase of RL training and to ensure human-friendly, readable output and formatting. This addresses a key limitation observed in DeepSeek-R1-Zero, which struggled with poor readability and language mixing due to its pure RL approach.\nThis data is constructed and collected from various approaches, including using few-shot prompting with long Chain-of-Thought (CoT) examples, directly prompting models to generate detailed answers with reflection and verification, and gathering readable outputs from DeepSeek-R1-Zero, which are then refined by human annotators through post-processing.\nPhi-4-mini-reasoning (Xu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Xu\u0026#32; Haoran,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Phi-4-Mini-Reasoning: Exploring the Limits of Small Reasoning Language Models in Math. https://doi.org/10.48550/arXiv.2504.21233 ) uses a combination of both automatic methods such as Math-Verify as well as LLMs as judges to assess the correctness of the generated answers. To maintain dataset balance, each sample is annotated with attributes including the domain category, the difficulty level, and the presence of repetitive patterns.\n2. Reasoning-oriented Reinforcement Learning. The Reinforcement Learning with Verifiable Rewards (RLVR) phase applies the same large-scale RL training process as used in DeepSeek-R1-Zero, which relies on the Group Relative Policy Optimization (GRPO) algorithm. This phase specifically focuses on improving the model\u0026rsquo;s reasoning capabilities in domains with well-defined problems and clear solutions, such as coding, mathematics, science, and logical reasoning. To mitigate the language mixing issues observed in DeepSeek-R1-Zero, DeepSeek-R1\u0026rsquo;s RL training in this stage introduces a \u0026ldquo;language consistency reward\u0026rdquo;.\nMath-Verify is utilised by many open projects to do automatic verification in the math domain (Xu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Xu\u0026#32; Haoran,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Phi-4-Mini-Reasoning: Exploring the Limits of Small Reasoning Language Models in Math. https://doi.org/10.48550/arXiv.2504.21233 ;\u0026#32;Guha\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Guha\u0026#32; Etash,\u0026#32;et al. \u0026#32; (2025). \u0026#32;OpenThoughts: Data Recipes for Reasoning Models. https://doi.org/10.48550/arXiv.2506.04178 ;\u0026#32;He\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 He\u0026#32; Jujie,\u0026#32;et al.(2025).\u0026#32;Retrieved from\u0026#32; https://capricious-hydrogen-41c.notion.site/Skywork-Open-Reaonser-Series-1d0bc9ae823a80459b46c149e4f51680 ;\u0026#32;Harris\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Harris\u0026#32;et al.(2025,\u0026#32;6/25).\u0026#32;Retrieved from\u0026#32; https://www.primeintellect.ai/blog/synthetic-1-release ;\u0026#32;Zhao\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Zhao\u0026#32; Han,\u0026#32;et al. \u0026#32; (2025). \u0026#32;1.4 Million Open-Source Distilled Reasoning Dataset to Empower Large Language Model Training. https://doi.org/10.48550/arXiv.2503.19633 ).\n3. Rejection Sampling and Supervised Fine-Tuning. When reasoning-oriented RL converges, the resulting checkpoint is used to collect SFT (Supervised Fine-Tuning) data for the subsequent round. Unlike the initial cold-start data, which primarily focuses on reasoning, this stage incorporates data from other domains to enhance the model’s capabilities in writing, role-playing, and other general-purpose tasks.\nReasoning data. Reasoning prompts are used to generate reasoning traces by performing rejection sampling from the checkpoint from the previous RL training. In the previous stage, only included data that could be evaluated using rule-based rewards. However, in this stage, the dataset is expanded by incorporating additional data, some of which use a generative reward model by feeding the ground-truth and model predictions into DeepSeek-V3 for judgment. Additionally, because the model output is sometimes chaotic and difficult to read, we have filtered out chain-of-thought with mixed languages, long paragraphs, and code blocks. Rejection sampling involves sampling multiple responses for each prompt and retaining only the correct ones. The dataset consists of about 600k samples.\nThe rejected samples are not always completely discarded. Phi-4-Mini-Reasoning (Xu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Xu\u0026#32; Haoran,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Phi-4-Mini-Reasoning: Exploring the Limits of Small Reasoning Language Models in Math. https://doi.org/10.48550/arXiv.2504.21233 ) also re-purposes the rejected (incorrect) rollouts for its \u0026ldquo;Rollout Preference Learning\u0026rdquo; stage. These incorrect responses, especially those with minor nuances compared to correct ones, are used to construct informative preference pairs, with correct answers designated as \u0026lsquo;preferred\u0026rsquo; and incorrect ones as \u0026lsquo;dis-preferred\u0026rsquo; for Direct Preference Optimization (DPO).\nNon-Reasoning Data. For non-reasoning data, such as writing, factual QA, self-cognition, and translation, the DeepSeek-V3 pipeline is used, and portions of the SFT dataset of DeepSeek-V3 are reused. For certain non-reasoning tasks, DeepSeek-V3 is called to generate a potential chain-of-thought before answering the question by prompting. However, for simpler queries, such as “hello,” a CoT is not provided in response. In the end, approximately 200k training samples unrelated to reasoning were collected.\nDeepSeek-V3-Base is then fine-tuned for two epochs using this curated dataset of about 800k samples.\n4.Reinforcement Learning for All Scenarios. To further align the model with human preferences, a secondary reinforcement learning stage is implemented aimed at improving the model\u0026rsquo;s helpfulness and harmlessness while simultaneously refining its reasoning capabilities. Specifically, the model is trained using a combination of reward signals and diverse prompt distributions. For reasoning data, the methodology outlined in DeepSeek-R1-Zero is followed, which utilizes rule-based rewards to guide the learning process in math, code, and logical reasoning domains.\nFor general data, reward models are used to capture human preferences in complex and nuanced scenarios. Specifically, for helpfulness, the assessment focuses exclusively on the final summary to emphasise the utility and relevance of the response. For harmlessness, the entire response (reasoning process and summary) is evaluated to mitigate potential risks, biases, or harmful content.\n","permalink":"https://atomwalk12.github.io/posts/lingalgzero/literature/","summary":"A review of existing approaches to training LLMs for math reasoning.","title":"LinAlgZero: Literature Review"},{"content":" Update (2025-07-13): Added a new section that summarises the process for generating the dataset. Main Workflow Figure ?? represents an illustration of the development process, organised around a two-stage workflow for training a reasoning language model.\nFigure\u0026nbsp;1: The development process includes five main phases: (1) SFT Dataset Generation (M.1-M.3), (2) SFT Training (M.4), (3) RLVR Data Curation (M.5), (4) RLVR Training (M.6), and (5) Deployment (M.7-M.9). M.1 Initial Raw Data Collection: Creating template schemes for various problem types (e.g. Matrix Multiplication, Linear Equations, etc.). Defines hyperparameters to ensure varying difficulty levels concerning the format and output constraints. M.2 Synthetic Data Generation: Generating raw problems via synthetic data generation. M.3 Data Distillation: Preparing the dataset for the Supervised Fine-Tuning (SFT) stage. S.1 Chain-of-Thought (CoT) Generation: Generating step-by-step reasoning traces for collected questions using a powerful \u0026ldquo;teacher\u0026rdquo; model (i.e. DeepSeek-R1). S.2 Verification: Validating the correctness of answers and CoTs through methods like Math Verify or LLM judges. S.3 Difficulty-Based Filtering: Selecting problems based on their difficulty level. Samples with moderate pass rates are retained, while those that are too easy or too hard are filtered out. Filtering may also involve learning impact measurement or off-the-shelf LLM judges. S.4 Rigorous Data Cleaning: Performing deduplication (via embedding similarity or n-gram), rejection sampling, and decontamination to ensure high-quality and unbiased data. M.4 Supervised Fine-tuning (SFT) Training: To enable the base model to imitate high-quality reasoning traces from stronger models. This phase serves as a baseline for stable training. The entire reasoning dataset is used. M.5 Reinforcement Learning from Verifiable Rewards (RLVR) Data Curation: This is a distinct and critical phase that involves preparing high-quality, verifiable datasets specifically for RL training. This includes: Construction of Verified Questions and Answers:: Gathering datasets for RL, often focused on math problems that can be objectively verified via automated tools. Difficulty-Based Filtering: RL datasets are often designed to include samples where models are likely to make mistakes (i.e., moderate pass rates), as samples that are too easy or too hard offer limited learning opportunities and are often filtered out. This differs from SFT\u0026rsquo;s general emphasis on difficulty and diversity to ensure data richness. Detailed Pre-processing (Verification, Filtering, Cleaning): Rigorous steps similar to SFT data preparation, but tailored for RL (e.g., filtering for samples with moderate pass rates, removing unverifiable formats, and ensuring decontamination). M.6 Reinforcement Learning from Verifiable Rewards (RLVR) Training: The core RL phase that further enhances reasoning capabilities. This process includes: V.1 RL Algorithm Implementation: Utilizing and adapting algorithms such as PPO, GRPO, or their variants. V.2 Reward System Design: Defining rule-based reward functions (e.g., accuracy, format, length) that guide the model\u0026rsquo;s learning process. V.3 Sampling Strategies and Curriculum Learning: Employing techniques like dynamic sampling, epoch-level history resampling, or progressively increasing context/response length to optimize training efficiency and stability. V.4 Reasoning Model: As a result of the actor-critic optimisations, a reasoning model is obtained. M.7 Model Evaluation: Attentive assessment of the Reasoning Language Model\u0026rsquo;s (RLM) performance on relevant benchmarks (e.g., AIME, MATH500). M.8 Further Refinement: The model can be quantized to facilitate easier adoption. M.9 Deployment and Release: Making the trained reasoning language model and dataset available on HuggingFace. Experimental setting This library utilises Qwen3-1.7B as the base model. However, other models that have been considered include: Qwen3-4B, Qwen3-0.6B, phi4-4B-instruct, gemma-3-1B and gemma-3-4B.\nPost-training Training methods. This library opts to analyse the model\u0026rsquo;s emergent reasoning abilities in two ways. One method involves Reinforcement Learning with Verifiable Rewards (RLVR), while the other is centred around a distillation process involving existing strong reasoning models. Figure ?? provides an illustration of the two processes. Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) suggests that training small models only using distillation yields better results than using RLVR, however in this library both methods are explored.\nFigure\u0026nbsp;2: Overview of the experimental setting in Qwen3: (1) RLVR for large models (\u0026gt;32B parameters), (2) Distillation for small models (\u0026lt;14B parameters). Our library demonstrates both approaches on a common base model: Qwen3-1.7B. (Image Source: Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) Experiment 1: RLVR Reinforcement Learning with Verifiable Rewards (RLVR) is a strategy for training LLMs where the reward signal is directly derived from the correctness of the model\u0026rsquo;s final answer on verifiable tasks. The technique was extensively used and pioneered by DeepSeek with their DeepSeek-R1-Zero paper (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ). Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) subsequently refines the process to include 3 key phases: cold-start SFT, RLVR and tool use.\nStep 1: Cold-Start SFT. SFT generally teaches the model to follow a desired prompt format, effectively facilitating convergence in the subsequent stages. This is necessary as pre-trained models are generally trained for text-completion, making their adherence to question-answering prompts difficult.\nQwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) utilises a challenging reasoning dataset exclusively for this phase, while Qwen2.5 (Qwen\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Qwen\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen2.5 Technical Report. https://doi.org/10.48550/arXiv.2412.15115 ) opts for a combination of both reasoning and non-reasoning traces of varying difficulty.\nStep 2: RLVR Training. The second phase (RLVR) is a critical post-training stage, designed to improve a model\u0026rsquo;s reasoning abilities. This ensures that through a step-by-step thinking process the solutions become verifiable.\nStep 3: Tool Use. Lastly, we anticipate a last phase designed to teach the model to use tools. This is a generalisation of the RLVR training process, where the model is trained to use tools to solve problems.\nExperiment 2: Distillation Qwen3 (Yang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Yang\u0026#32; An,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Qwen3 Technical Report. https://doi.org/10.48550/arXiv.2505.09388 ) suggests that the small models ($\\leq$ 14B parameters) perform better when trained using distillation instead of the full-fledged RLVR training. This distillation process is composed of two phases, namely off-policy and on-policy distillation.\nThis section introduces the key concepts around the knowledge-distillation process, first proposed by (Hinton\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2015 Hinton\u0026#32; Geoffrey,\u0026#32;et al. \u0026#32; (2015). \u0026#32;Distilling the Knowledge in a Neural Network. https://doi.org/10.48550/arXiv.1503.02531 ). Also, an analysis of the theory involved is available in this post.\nOff-policy Distillation. Aims to to use the outputs of a teacher (i.e. Qwen3-32B) model to demonstrate basic reasoning skills to a smaller model (i.e. Qwen3-1.7B-Base). This phase is less memory intensive than the on-policy phase as the responses of the teacher can be generated in advance. The smaller model is fine-tuned on the teacher\u0026rsquo;s responses, which lays as a solid foundation for the on-policy phase.\nOn-policy Distillation. During this phase, both the student and the teacher generate their own responses to queries sampled from the reasoning dataset. The student model is then fine-tuned by aligning its logits with those of the teacher model by minimising KL-divergence. This allows the student to expand its exploration space and enhance its reasoning abilities, while requiring a substantially lesser amount of GPU hours (1/10th) compared to utilising solely RLVR.\nImplementation Surveys. There exist various surveys on the topic of knowledge distillation (Xu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2024 Xu\u0026#32; Xiaohan,\u0026#32;et al. \u0026#32; (2024). \u0026#32;A Survey on Knowledge Distillation of Large Language Models. https://doi.org/10.48550/arXiv.2402.13116 ;\u0026#32;Gou\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2021 Gou\u0026#32; Jianping,\u0026#32;et al. \u0026#32; (2021). \u0026#32;Knowledge Distillation: A Survey. International Journal of Computer Vision,\u0026#32;129(6).\u0026#32;1789–1819. https://doi.org/10.1007/s11263-021-01453-z ), with various studies effectively demonstrating correct implementations of the distillation process. Below are compiled insights on the distillation process.\nTraining Heuristics. FastFormers (Kim\u0026#32;\u0026amp;\u0026#32;Awadalla,\u0026#32;2020 Kim\u0026#32; Young Jin\u0026#32;\u0026amp;\u0026#32;Awadalla\u0026#32; Hany Hassan. \u0026#32; (2020). \u0026#32;FastFormers: Highly Efficient Transformer Models for Natural Language Understanding. https://doi.org/10.48550/arXiv.2010.13382 ) provides great insights into the mechanics of the distillation process, namely what works and what doesn\u0026rsquo;t.\nNOTE: The FastFormers paper suggests differentiating between task-agnostic and task-specific fine-tuning. The later involves fine-tuning the teacher on the dataset prior to initiating the distillation process, which may lead to better accuracy. See Figure 1 of the paper.\nMoreover, it suggests that the distillation process is only effective as long as the tokenizers of each model produce the same output given similar inputs. The study postulates that different tokenizer embedding spaces result in different output embedding spaces, and this leads to knowledge transfer being not as effective. So, a similar check is necessary:\nfrom transformers import AutoTokenizer # Initialise tokenizers teacher = AutoTokenizer.from_pretrained(TEACHER_ID) student = AutoTokenizer.from_pretrained(STUDENT_ID) # Input sample = \u0026#34;Some sample text.\u0026#34; # Assert results assert teacher(sample) == student(sample), \u0026#34;Teacher/Student tokenizer mismatch\u0026#34; Dataset generation The central idea is to generate a bare linear algebra dataset with problems of varying difficulty, then use a pre-trained model to solve these problems using chain-of-thought reasoning and function calling. Below are summarised the main contributions:\nBare dataset of problems (SymPy). The specific linear algebra problem definitions are yet to be precisely defined, however some possible problem types include: finding the inverse of a matrix, solving systems of linear equations, calculating eigenvalues and eigenvectors, performing LU, QR, and Singular Value Decompositions (SVD), and determining the nullspace of a matrix. The problems are defined based on the input parameters (which are combined to form the problem statement), and the output result (which is the solution to the problem).\nSFT dataset generation (Distilabel \u0026amp; MathVerify). The bare dataset is prepared for SFT training. A powerful model such as DeepSeek-R1 (70b) is used to solve the problems generated at step 1 using chain-of-thought reasoning and tool calling. The results are synthesized using distilabel and MathVerify to facilitate the synthetic structured solution generation and ensure correctness respectively. The dataset must follow specific conventions for the SFT training process, some of which are detailed on the Huggingface documentation (link 1 and link 2).\nSFT training (TRL). The model goes through an initial supervised fine-tuning (SFT) process, ensuring that it can memorise high-quality reasoning traces. The pre-trained (base) model is not equipped with strong conversational abilities, as in general the training data during the pre-training phase enhances its abilities to do text-completion, rather than to engage in conversations. The exposure to high-quality reasoning traces improve its reasoning abilities and facilitates convergence in the subsequent phases. This utilises the SFTTrainer trainer, without any external tools.\nReinforcement Learning (Verl \u0026amp; MathVerify). During the last step, the model is trained using reinforcement learning to learn to solve linear algebra problems. We use Verl as the training framework, while the correctness of the generated responses is assessed using MathVerify, which provides a deterministic reward signal.\n","permalink":"https://atomwalk12.github.io/posts/lingalgzero/linalgzero/","summary":"A toolkit for generating a linear algebra dataset and training models for linear algebra reasoning.","title":"LinAlgZero: A linear algebra dataset for reasoning"},{"content":"The following notes are borrowed from (Zhang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Zhang\u0026#32; Chong,\u0026#32;et al. \u0026#32; (2025). \u0026#32;100 Days After DeepSeek-R1: A Survey on Replication Studies and More Directions for Reasoning Language Models. https://doi.org/10.48550/arXiv.2505.00551 ). I will revise them as my understanding improves.\nSupervised Fine-tuning Definition\u0026nbsp;1\u0026nbsp;(SFT Loss).\u0026nbsp; Given a dataset $\\mathcal{D}_{\\text{SFT}} \\triangleq \\left\\{ (q_i, c_i) \\right\\}_{i=1}^{|\\mathcal{D}|}$, where each sample $(q_i, c_i)$ consists of a question $q_i$ and a long CoT $c_i$. The long CoT can be further decomposed into a complex intermediate rationale followed by a final answer. SFT updates the parameters of the policy model $\\pi_{\\theta}$ by minimizing the negative log-likelihood loss: $$ \\begin{aligned} \\mathcal{L}_{\\text{SFT}}(\\theta) \\triangleq - \\mathbb{E}_{(q, c) \\sim \\mathcal{D}_{\\text{SFT}}} \\left[ \\log \\pi_{\\theta}(c \\mid q) \\right], \\end{aligned} $$ where $\\pi_{\\theta}(c \\mid q)$ denotes the probability assigned by the policy to the CoT response $c$ conditioned on the question $q$. This objective encourages the model to imitate the supervised demonstrations by maximizing the likelihood of the reference completions. In the following example, if each sample is equally likely to be selected, then the expectation operator is averaging the negative log-likelihood loss across all training examples in the dataset: $$ \\mathbb{E}_{(q,c) \\sim \\mathcal{D}_{\\text{SFT}}}[\\log \\pi_\\theta(c | q)] = \\frac{1}{|\\mathcal{D}_{\\text{SFT}}|} \\sum_{i=1}^{|\\mathcal{D}_{\\text{SFT}}|} \\log \\pi_\\theta(c_i | q_i) $$ LLM Policy Optimization Recent studies have introduced a groundbreaking post-training paradigm that enhances LLMs' reasoning capabilities through RL-based training. In this framework, the LLM's answer generation process for each query is formulated as an answer sampling policy, and our objective is to optimize this LLM policy to maximize the expected reward of the generated responses. According to (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ;\u0026#32;Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ;\u0026#32;Team\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Team\u0026#32; Kimi,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Kimi k1.5: Scaling Reinforcement Learning with LLMs. https://doi.org/10.48550/arXiv.2501.12599 ), large-scale RL-based LLM policy optimization enables the base LLM to achieve a steady improvement in reasoning accuracy while also exhibiting the emergence of long-chain reasoning in its chain-of-thought. Definition\u0026nbsp;2\u0026nbsp;(LLM Policy Optimization).\u0026nbsp; Suppose each reasoning data pair $(q,a)$ is i.i.d sampled from an underlying distribution $\\mathcal{D}$, where each $q$ is a query and $a$ is the corresponding ground-truth answer. Let $\\pi_{\\theta}(\\cdot | \\cdot)$ be the target LLM policy parameterized by $\\theta$. The expected reward of the LLM on a sample $(q,a)$ is $\\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot | q)} [r(o, a)]$, where $o$ is an LLM-generated response to $q$, and $r(\\cdot,\\cdot)$ is a predefined reward function that quantifies whether the response $o$ yields $a$. The objective of RL-based fine-tuning is to maximize the expected reward over the data distribution, i.e., $$ \\begin{align*} \\max_{\\theta} J(\\pi_{\\theta}) \\triangleq \\mathbb{E}_{(q,a)\\sim \\mathcal{D}} \\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot|q)} [r(o, a)]. \\end{align*} $$ A straightforward approach to maximize $J(\\pi_{\\theta})$ is to gradually improve the LLM's parameter $\\theta$ towards the policy gradient direction $\\nabla_{\\theta} J(\\pi_{\\theta})$. However, since $ \\nabla_{\\theta} \\mathbb{E}_{o \\sim \\pi_{\\theta}(\\cdot | q)} r(o, a) $ is the gradient of an integral dependent on $ \\pi_\\theta $, $ \\nabla_{\\theta} J(\\pi_{\\theta}) $ is intractable to compute via standard Monte Carlo sampling. Fortunately, the RL community has developed two powerful policy gradient estimators: REINFORCE (Williams,\u0026#32;1992 Williams\u0026#32; Ronald J.. \u0026#32; (1992). \u0026#32;Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning,\u0026#32;8(3).\u0026#32;229–256. https://doi.org/10.1007/BF00992696 ) and Importance Sampling (Sutton\u0026#32;\u0026amp;\u0026#32;Barto,\u0026#32;2025 Sutton\u0026#32; Richard\u0026#32;\u0026amp;\u0026#32;Barto\u0026#32; Andrew.(2025,\u0026#32;6/27).\u0026#32;Retrieved from\u0026#32; http://incompleteideas.net/book/the-book-2nd.html ): $$\\small \\begin{align*} \\nabla_{\\theta} \\mathbb{E}_{o\\sim \\pi_{\\theta}(\\cdot|q)} r(o, a) = \\begin{cases} \\mathbb{E}_{o \\sim \\pi_{\\theta}(\\cdot|q)} \\left[ \\nabla_{\\theta} \\log \\pi_{\\theta}(o|q) \\cdot r(o, a) \\right]\\ \u0026\\text{(REINFORCE)}, \\\\ \\mathbb{E}_{o \\sim \\pi_{\\theta'}(\\cdot|q)} \\left[ \\nabla_{\\theta} \\left( \\frac{\\pi_{\\theta}(o|q)}{\\pi_{\\theta'}(o|q)} \\right) \\cdot r(o, a) \\right]\\ \u0026\\text{(Importance Sampling)}, \\end{cases} \\end{align*} $$ where $\\pi_{\\theta'}$ is any parameter-frozen LLM policy. Hence, the policy gradient $\\nabla_{\\theta} J(\\pi_\\theta)$ can be effectively approximated using standard Monte Carlo sampling: for each data pair $(q,a)$, we independently generate $G$ responses to $q$, denoted by $\\{o_i\\}_{i=1}^G$, using the current LLM $\\pi_\\theta$ or the frozen LLM $\\pi_{\\theta'}$, and then approximate the policy gradient estimators by $$\\footnotesize \\begin{align*} \\nabla_{\\theta} J(\\pi_\\theta) = \\begin{cases} \\mathbb{E}_{(q,a)\\sim \\mathcal{D},\\{o_i\\}_{i=1}^G\\sim \\pi_{\\theta}(\\cdot|q)} \\left[ \\frac{1}{G} \\sum_{i=1}^G \\nabla_{\\theta} \\log \\pi_{\\theta}(o_i|q) \\cdot r(o_i, a) \\right] \u0026\\text{(REINFORCE)}, \\\\ \\mathbb{E}_{(q,a)\\sim \\mathcal{D},\\{o_i\\}_{i=1}^G\\sim \\pi_{\\theta'}(\\cdot|q)} \\left[ \\frac{1}{G} \\sum_{i=1}^G \\nabla_{\\theta} \\left( \\frac{\\pi_{\\theta}(o_i|q)}{\\pi_{\\theta'}(o_i|q)} \\right) \\cdot r(o_i, a) \\right] \u0026 \\text{(Importance Sampling)}, \\end{cases} \\end{align*} $$ For each query $q$, the procedure of generating $G$ independent responses $\\{o_{i}\\}_{j=1}^G$ from $\\pi_{\\theta}(\\cdot|q)$ is called the `rollout phase'. During this phase, the LLM policy explores enormous response samples of varying quality. Then $\\theta$ is updated to increase the likelihood $ \\pi_{\\theta}(o_i|q) $ where $ r(o_i, a)$ is large, thereby improving the likelihood of generating responses with high rewards. Specifically, REINFORCE is an on-policy method that requires generating new rollouts using the latest LLM policy $ \\pi_{\\theta} $. In contrast, the importance sampling estimator can be implemented in an off-policy manner with improved sampling efficiency, as it can reuse past rollouts generated from $\\pi_{\\theta'}$ by storing the corresponding probability terms $ \\pi_{\\theta'}(o_i | q)$. A common choice is to implement $\\pi_{\\theta'}$ as $\\pi_{\\theta_{\\mathrm{old}}}$, a past snapshot of the target LLM $\\pi_\\theta$, which is updated periodically. In practice, the reward signals $\\{r(o_i, a)\\}_{i=1}^G$ are highly sparse, leading to high variance in rollout phases and policy gradient estimation. To mitigate these issues, various techniques have been developed to stabilize LLM policy gradient estimation in (\\ref{eq:rl_policy_grad_estimator}). These techniques generally fall into three categories: 1) reducing sampling variance by reward normalization or using actor-critic advantage estimation, 2) stabilizing parameter updates by clipping the importance sampling weight $ \\pi_\\theta(o_i|q) / \\pi_{\\theta_{\\mathrm{old}}}(o_i|q)$, and 3) constraining policy shifts by penalizing the KL-divergence $\\mathrm{KL}(\\pi_{\\theta} | \\pi_{\\mathrm{ref}})$ between the current LLM policy $\\pi_{\\theta}$ and a fixed reference LLM policy $\\pi_{\\mathrm{ref}}$. RLVR PPO Since its introduction in (Schulman\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2017 Schulman\u0026#32; John,\u0026#32;et al. \u0026#32; (2017). \u0026#32;Proximal Policy Optimization Algorithms. https://doi.org/10.48550/arXiv.1707.06347 ), Proximal Policy Optimization (PPO) has become one of the most popular actor-critic RL algorithms for LLM policy optimization (Ouyang\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2022 Ouyang\u0026#32; Long,\u0026#32;et al. \u0026#32; (2022). \u0026#32;Training language models to follow instructions with human feedback. ArXiv.\u0026#32;Retrieved from\u0026#32; https://www.semanticscholar.org/paper/Training-language-models-to-follow-instructions-Ouyang-Wu/d766bffc357127e0dc86dd69561d5aeb520d6f4c ;\u0026#32;Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ). In addition to the target LLM policy $\\pi_\\theta$, which serves as the actor model, PPO introduces a critic model $V_{\\phi} $—another LLM designed to learn the value for the responses generated by the actor LLM $\\pi_\\theta$. Specifically, the PPO objective is $$\\small \\begin{equation*} \\begin{aligned} J_{\\mathrm{PPO}}(\\pi_\\theta) \\triangleq \u0026\\ \\mathbb{E}_{(q, a) \\sim \\mathcal{D},\\left\\{o_i\\right\\}_{i=1}^G \\sim \\pi_{\\theta_{\\text{old}}}(\\cdot \\mid q)} \\\\ \\Bigg[ \u0026 \\frac{1}{G} \\sum_{i=1}^G \\frac{1}{\\left| o_i \\right|} \\sum_{t=1}^{\\left|o_i\\right|} \\left( \\min \\Big( r_{i, t}(\\theta) \\textcolor{red}{\\hat{A}_{i, t}(\\phi)}, \\textcolor{red}{\\operatorname{clip}}\\left(r_{i, t}(\\theta), 1 - \\varepsilon, 1 + \\varepsilon\\right) \\textcolor{red}{\\hat{A}_{i, t}(\\phi)} \\Big) \\right) \\Bigg], \\end{aligned} \\end{equation*} $$ where $r_{i,t}(\\theta)\\triangleq \\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})/ \\pi_{\\theta_{\\mathrm{old}}}(o_{i,t}|q,o_{i, \u003c t})$ denotes the likelihood ratio between the current LLM policy $\\pi_\\theta$ and the past LLM policy $\\pi_{\\theta'}$ calculated on the $t$-th token prediction step; $\\hat{A}_{i, t}(\\phi)$ denotes the Generalized Advantage Estimator (GAE) (Schulman\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2018 Schulman\u0026#32; John,\u0026#32;et al. \u0026#32; (2018). \u0026#32;High-Dimensional Continuous Control Using Generalized Advantage Estimation. https://doi.org/10.48550/arXiv.1506.02438 ) computed using the estimated value $V_{\\phi}(o_{i,t}|q,o_{i, \u003c t})$, which estimates the quality of each response generation state. $ V_{\\phi} $ is trained along with $\\pi_{\\theta}$ to predict the value of the response generated by $\\pi_{\\theta}$. In practice (Hu\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 Hu\u0026#32; Jingcheng,\u0026#32;et al. \u0026#32; (2025). \u0026#32;Open-Reasoner-Zero: An Open Source Approach to Scaling Up Reinforcement Learning on the Base Model. https://doi.org/10.48550/ARXIV.2503.24290 ), GAE is observed to be a more robust response quality estimator than the raw reward $r(q_i,a^*_i)$, leading to more stable LLM policy optimization. GRPO Group Relative Policy Optimization (GRPO) is first proposed (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ) as an effective and efficient variant of PPO. Specifically, GRPO discards the critic model and GAE calculation in PPO to improve efficiency and memory consumption. To reduce the reward sampling variance, GRPO normalizes the rewards within a group of $G$ rollout outs. In addition to clipping the likelihood ratio terms, GRPO further introduces KL-divergence penalty to ensure that $\\pi_\\theta$ would not be driven far away from the initial SFT LLM. Specifically, the GRPO objective is\n$$\\footnotesize \\begin{equation*} \\begin{align*} J_{\\mathrm{GRPO}}(\\pi_\\theta) \\triangleq \u0026\\ \\mathbb{E}_{(q, a) \\sim \\mathcal{D},\\left\\{o_i\\right\\}_{i=1}^G \\sim \\pi_{\\theta_{\\text{old}}}(\\cdot \\mid q)} \\\\ \\Bigg[ \u0026 \\frac{1}{G} \\sum_{i=1}^G \\frac{1}{\\left| o_i \\right|} \\sum_{t=1}^{\\left|o_i\\right|} \\left( \\min \\Big( r_{i, t}(\\theta) \\textcolor{red}{\\hat{A}_{i, t}}, \\operatorname{clip}\\left(r_{i, t}(\\theta), 1 - \\varepsilon, 1 + \\varepsilon\\right) \\textcolor{red}{\\hat{A}_{i, t}} \\Big) - \\textcolor{red}{\\beta \\mathrm{KL}(\\pi_{\\theta}|\\pi_{\\mathrm{ref}})}_{i,t} \\right) \\Bigg], \\end{align*} \\end{equation*} $$ where $\\hat{A}_{i,t} \\triangleq (r(o_i,a) - \\mathrm{mean}(\\{r(o_i,a)\\}_{i=1}^G))/\\mathrm{std}(\\{r(o_i,a)\\}_{i=1}^G)$ denotes the group relative reward, and $\\mathbf{r} \\triangleq \\{r(o_i,a)\\}_{i=1}^G$ denotes the rewards of the response group corresponding to each sample $(q,a)$. GRPO also incorporates the K3 KL-divergence estimator (Schulman,\u0026#32;2020 Schulman\u0026#32; John.(2020,\u0026#32;3/7).\u0026#32;Retrieved from\u0026#32; http://joschu.net/blog/kl-approx.html ): $$ \\begin{align*} \\mathrm{KL}(\\pi_{\\theta}|\\pi_{\\mathrm{ref}})_{i,t} \\triangleq \\frac{\\pi_{\\mathrm{ref}}(o_{i,t}|q,o_{i, \u003c t})}{\\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})} - \\log \\frac{\\pi_{\\mathrm{ref}}(o_{i,t}|q,o_{i, \u003c t})}{\\pi_{\\theta}(o_{i,t}|q,o_{i, \u003c t})} - 1. \\end{align*} $$ DeepSeek-R1 (DeepSeek-AI\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2025 DeepSeek-AI\u0026#32;et al. \u0026#32; (2025). \u0026#32;DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning. https://doi.org/10.48550/arXiv.2501.12948 ) shows that GRPO achieves stable large-scale LLM policy optimization that incentivises the long CoT pattern in large-scale LLMs.\nDistillation The following concepts are based on (Hinton\u0026#32; \u0026#32;et\u0026#32;al.,\u0026#32;2015 Hinton\u0026#32; Geoffrey,\u0026#32;et al. \u0026#32; (2015). \u0026#32;Distilling the Knowledge in a Neural Network. https://doi.org/10.48550/arXiv.1503.02531 ). They are currently being written.\nGradient Accumulation Definition\u0026nbsp;3\u0026nbsp;(Gradient Accumulation).\u0026nbsp; Below is an explanation on how to adjust the gradient accumulation steps when changing the number of GPUs. The goal is to keep the Global Batch Size constant. The formula for it is: $$\\footnotesize \\text{Global Batch Size} = (\\text{Number of GPUs}) \\times (\\text{Per-Device Batch Size}) \\times (\\text{Gradient Accumulation Steps}) $$ Derivation: The goal is to show how to adjust the parameters to keep the Global Batch Size constant when the number of GPUs changes. Suppose we use the subscript `_old` r the original values and `_new` for the new values. The principle is: $$ \\text{Global Batch Size}_{old} = \\text{Global Batch Size}_{new} $$ Therefore: $$\\footnotesize (\\text{GPUs}_{old} \\times \\text{Batch Size}_{old} \\times \\text{Accumulation}_{old}) = (\\text{GPUs}_{new} \\times \\text{Batch Size}_{new} \\times \\text{Accumulation}_{new}) $$ To find the new required number of gradient accumulation steps, the formula is rearranged as follows: $$ \\text{Accumulation}_{new} = \\frac{(\\text{GPUs}_{old} \\times \\text{Batch Size}_{old} \\times \\text{Accumulation}_{old})}{(\\text{GPUs}_{new} \\times \\text{Batch Size}_{new})} $$ This shows how the gradient accumulation steps are affected by the number of GPUs. ◼\nExample\u0026nbsp;1\u0026nbsp;(Gradient Accumulation).\u0026nbsp;Suppose the following values are given:\nGPUs_old: 8 Batch Size_old: 16 Accumulation_old: 4 GPUs_new: 1 Batch Size_new: 16 (this is limited by the GPU\u0026rsquo;s memory) Plugging these into the formula to find the new gradient accumulation steps: $$ \\text{Accumulation}_{new} = \\frac{(8 \\times 16 \\times 4)}{(1 \\times 16)} = \\frac{512}{16} = 32 $$ This is why the gradient_accumulation_steps should be updated to 32 in the configuration file.\nLoRA Theory Local development leverages LoRA to reduce the number of trained parameters, effectively facilitating local debugging and development.\nLoRA paper LoRA adaptation for TRL ","permalink":"https://atomwalk12.github.io/posts/lingalgzero/theory/","summary":"A toolkit for generating a linear algebra dataset and training models for linear algebra reasoning.","title":"LinAlgZero: Theory"},{"content":" Q:\u0026nbsp;How can I get an update when a new post comes out?\nIt is possible to subscribe to the RSS feed to be notified via email. Q:\u0026nbsp;How to find interesting Wikipedia articles?\nPetScan is a useful tool to filter and analyse Wikipedia articles based on categories and other criteria. It is a great tool to discover new topics to read about. Q:\u0026nbsp;How do you organize your code snippets?\nI use Github Gists to store code that is useful to reuse across projects. Q:\u0026nbsp;Blogs that are particularly interesting?\nHuggingface Blog Deeplearning.ai ","permalink":"https://atomwalk12.github.io/resources/","summary":"A list of resources I find useful.","title":"FAQ"}]